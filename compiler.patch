diff --git a/code-gen.ml b/code-gen.ml
index dd80017..ffdafff 100644
--- a/code-gen.ml
+++ b/code-gen.ml
@@ -32,8 +32,409 @@ module type CODE_GEN = sig
 end;;
 
 module Code_Gen : CODE_GEN = struct
-  let make_consts_tbl asts = raise X_not_yet_implemented;;
-  let make_fvars_tbl asts = raise X_not_yet_implemented;;
-  let generate consts fvars e = raise X_not_yet_implemented;;
+
+
+  let remove_dup pred lst set =
+    let rec remove_dup_rec lst set =
+    match lst with
+    | [] -> set    
+    | hd :: tail -> if (List.exists (fun(element) -> pred hd element) set) 
+                  then (remove_dup_rec tail set) 
+                  else (remove_dup_rec tail (set @ [hd])) in
+    remove_dup_rec lst set;; 
+
+  let make_consts_set lst =
+    let const_eq v1 v2 =
+      match v1, v2 with
+      | Const'(Sexpr x), Const'(Sexpr y) -> sexpr_eq x y
+      | _ -> false in
+    remove_dup const_eq lst [];;
+
+  let consts_to_sexprs const_set =
+    let rec const_to_sexpr const =
+      match const with 
+      | Const'(Void) :: tail -> const_to_sexpr tail
+      | Const'(Sexpr(sexpr)) :: tail -> 
+      (expand_sexpr sexpr) @ 
+      (const_to_sexpr tail)
+      | [] -> [] 
+      | _ -> raise X_this_should_not_happen
+
+    and expand_sexpr sexpr =
+      match sexpr with
+      | Pair(car, cdr) -> (expand_sexpr car) @ (expand_sexpr cdr) @ [Sexpr(sexpr)]
+      | Symbol(a) -> [Sexpr(String (a)) ; Sexpr(sexpr)]
+      | Number(num) -> [Sexpr(Number(num))]
+      | Char(c) -> [Sexpr(Char(c))]
+      | String(s) -> [Sexpr(String(s))]
+      | _ -> [] in
+
+    const_to_sexpr const_set ;;
+  let make_sexpr_set lst =
+    let _sexpr_eq s1 s2 =
+      match s1, s2 with
+      | Sexpr(Bool(b1)), Sexpr(Bool(b2)) -> b1 = b2
+      | Sexpr(Nil), Sexpr(Nil) -> true
+      | Sexpr(Number(Float f1)), Sexpr(Number(Float f2)) -> abs_float(f1 -. f2) < 0.001
+      | Sexpr(Number(Fraction (n1, d1))), Sexpr(Number(Fraction (n2, d2))) -> n1 = n2 && d1 = d2
+      | Sexpr(Char(c1)), Sexpr(Char(c2)) -> c1 = c2
+      | Sexpr(String(s1)), Sexpr(String(s2)) -> s1 = s2
+      | Sexpr(Symbol(s1)), Sexpr(Symbol(s2)) -> s1 = s2
+      | Sexpr(Pair(car1, cdr1)), Sexpr(Pair(car2, cdr2)) -> (sexpr_eq car1 car2) && (sexpr_eq cdr1 cdr2)
+      | _ -> false in
+    remove_dup _sexpr_eq lst [];;
+
+  let add_offsets sexprs_list =
+    let rec add_offset lst offset =
+      match lst with
+      | [] -> []
+      | Void :: tail -> [(Void, offset)] @ add_offset tail (offset+1)
+      | Sexpr(Bool x) :: tail -> [(Sexpr(Bool x), offset)] @ add_offset tail (offset+2)
+      | Sexpr(Nil) :: tail -> [(Sexpr(Nil), offset)] @ add_offset tail (offset+1)
+      | Sexpr(Number(Fraction (x,y))) :: tail -> [(Sexpr(Number(Fraction (x,y))), offset)] @ add_offset tail (offset+17)
+      | Sexpr(Number(Float x)) :: tail -> [(Sexpr(Number(Float x)), offset)] @ add_offset tail (offset+9)
+      | Sexpr(Char c) :: tail -> [(Sexpr(Char c), offset)] @ add_offset tail (offset+2)
+      | Sexpr(String s) :: tail -> [(Sexpr(String s), offset)] @ add_offset tail (offset+ 9 + (String.length s))
+      | Sexpr(Symbol s) :: tail -> [(Sexpr(Symbol s), offset)] @ add_offset tail (offset+9)
+      | Sexpr(Pair(car, cdr)) :: tail -> [(Sexpr(Pair(car,cdr)), offset)] @ add_offset tail (offset+17) in
+      add_offset sexprs_list 0;;
+      
+
+    let tupels_to_tripels tupels =
+      let find_offset const tupels  = 
+        List.assoc const tupels in
+      let rec tupel_to_tripel lst = 
+        match lst with
+        | [] -> []
+        | (Void, ofs) :: tail -> [(Void, (ofs, "db T_VOID"))] @ tupel_to_tripel tail 
+        | (Sexpr(Bool false), ofs) :: tail -> [(Sexpr(Bool false), (ofs, "db T_BOOL, 0"))] @ tupel_to_tripel tail
+        | (Sexpr(Bool true), ofs) :: tail -> [(Sexpr(Bool true), (ofs, "db T_BOOL, 1"))] @ tupel_to_tripel tail
+        | (Sexpr(Nil), ofs) :: tail -> [(Sexpr(Nil), (ofs, "db T_NIL"))] @ tupel_to_tripel tail
+        | (Sexpr(Number(Fraction (x,y))), ofs) :: tail -> [(Sexpr(Number(Fraction (x, y))), (ofs, "MAKE_LITERAL_RATIONAL ("^(string_of_int x)^" ,"^(string_of_int y)^")"))] @ tupel_to_tripel tail
+        | (Sexpr(Number(Float x)), ofs) :: tail -> [(Sexpr(Number(Float x)), (ofs, "MAKE_LITERAL_FLOAT ("^(string_of_float x)^")"))] @ tupel_to_tripel tail
+        | (Sexpr(Char c), ofs) :: tail -> [(Sexpr(Char c), (ofs, "MAKE_LITERAL_CHAR ("^ (string_of_int (int_of_char c))^ ")"))] @ tupel_to_tripel tail
+        | (Sexpr(String s), ofs) :: tail -> [(Sexpr(String s), (ofs, "MAKE_LITERAL_STRING \""^s^"\" "))] @ tupel_to_tripel tail
+        | (Sexpr(Symbol s), ofs) :: tail -> [(Sexpr(Symbol s), (ofs, "MAKE_LITERAL_SYMBOL (const_tbl+" ^ (string_of_int (find_offset (Sexpr(String s)) tupels))^")"))] @ tupel_to_tripel tail
+        | (Sexpr(Pair(car, cdr)), ofs) :: tail -> [(Sexpr(Pair(car, cdr)), 
+                                                    (ofs, "MAKE_LITERAL_PAIR (const_tbl+" ^ 
+                                                          (string_of_int (find_offset (Sexpr(car)) tupels)) ^ " , const_tbl+" ^ 
+                                                          (string_of_int (find_offset (Sexpr(cdr)) tupels))^ ")"))] @ tupel_to_tripel tail in
+        (* | _ -> X_this_should_not_happen in *)
+
+
+    tupel_to_tripel tupels;;
+
+  let consts_tbl_maker  asts = 
+    let rec find_const expr' = 
+      match expr' with
+      | Const'(x) ->  [Const'(x)]
+      | Var'(x) -> []
+      | If'(test, dit, dif) -> (find_const test) @ (find_const dit) @ (find_const dif)
+      | Box'(x) -> []
+      | BoxSet'(v, e) -> (find_const e)
+      | BoxGet'(v) -> []
+      | Seq'(lst) -> (List.fold_left List.append [] (List.map find_const lst))
+      | Set'(v, e) -> (find_const e)
+      | Def'(v, e) -> (find_const e)
+      | Or'(lst) -> (List.fold_left List.append [] (List.map find_const lst))
+      | LambdaSimple'(args, body) -> (find_const body)
+      | LambdaOpt'(args, args_opt ,body) -> (find_const body)
+      | Applic'(rator, rands) -> (find_const rator) @ (List.fold_left List.append [] (List.map find_const rands))
+      | ApplicTP'(rator, rands) -> (find_const rator) @ (List.fold_left List.append [] (List.map find_const rands)) in
+
+    let consts_set = make_consts_set(List.fold_left List.append [] (List.map find_const asts)) in
+    let sexpr_set = [Void; Sexpr(Nil); Sexpr(Bool false); Sexpr(Bool true)] @ make_sexpr_set (consts_to_sexprs consts_set) in
+    tupels_to_tripels (add_offsets sexpr_set)  
+
+      ;;
+
+  let rec make_fvar_set lst set  =
+    let varfree_eq v1 v2 =
+      match v1, v2 with
+      | VarFree(x), VarFree(y) -> String.equal x y
+      | _ -> false in
+    remove_dup varfree_eq lst set;;
+
+  let rec vars_to_pairs vars pairs i =
+    match vars with
+    | VarFree(x) :: tail -> [x, i] @ (vars_to_pairs tail pairs (i+8))
+    | [] -> pairs
+    | _ -> raise X_this_should_not_happen;;
+
+  let fvar_tbl_maker asts =
+    let rec find_fvars expr' =
+    match expr' with
+    | Const'(x) -> []
+    | Var'(VarFree(x)) -> [VarFree(x)]
+    | Var'(x) -> []    
+    | If'(test, dit, dif) -> (find_fvars test) @ (find_fvars dit) @ (find_fvars dif)                                  
+    | Box'(x) -> []
+    | BoxSet'(v, e) -> (find_fvars e)
+    | BoxGet'(v) -> []
+    | Seq'(lst) -> (List.fold_left List.append [] (List.map find_fvars lst))   
+    | Set'(VarFree(x), e) -> [VarFree(x)] @ (find_fvars e)
+    | Set'(v, e) -> (find_fvars e)
+    | Def'(VarFree(x), e) -> [VarFree(x)] @ (find_fvars e)
+    | Def'(v, e) -> (find_fvars e)
+    | Or'(lst) -> (List.fold_left List.append [] (List.map find_fvars lst))   
+    | LambdaSimple'(args, body) -> (find_fvars body)
+    | LambdaOpt'(args, args_opt, body) -> (find_fvars body)
+    | Applic'(rator, rands) -> (find_fvars rator) @ (List.fold_left List.append [] (List.map find_fvars rands))  
+    | ApplicTP'(rator, rands) -> (find_fvars rator) @ (List.fold_left List.append [] (List.map find_fvars rands))  in 
+    
+    let freeVarsList = List.flatten (List.map find_fvars asts) in
+    let freeVarSet = make_fvar_set freeVarsList [] in
+    
+    ["boolean?", 0; "flonum?", 8; "rational?", 16;
+    "pair?", 24; "null?", 32; "char?", 40; "string?", 48;
+    "procedure?", 56; "symbol?", 64;
+    (* String procedures *)
+    "string-length", 72; "string-ref", 80; "string-set!", 88;
+    "make-string", 96; "symbol->string", 104;
+    (* Type conversions *)
+    "char->integer", 112; "integer->char", 120; "exact->inexact", 128;
+    (* Identity test *)
+    "eq?", 136;
+    (* Arithmetic ops *)
+    "+", 144; "*", 152; "/", 160; "=", 168; "<", 176;
+    (* Additional rational numebr ops *)
+    "numerator", 184; "denominator", 192; "gcd", 200; 
+    (* our functions*) 
+    "apply", 208; "car", 216; "cons", 224; "cdr", 232; "set-car!", 240; "set-cdr!", 248] @ vars_to_pairs freeVarSet [] 256
+    ;; 
+
+  let make_consts_tbl asts = consts_tbl_maker asts ;;
+  
+  let make_fvars_tbl asts = fvar_tbl_maker asts ;;
+
+  let if_counter = ref 0;;
+  let or_counter = ref 0;;
+  let lambda_counter = ref 0;;
+  let inc_and_get_counter counter = 
+    counter := (!counter+1);
+    !counter;;    
+
+  let generate consts fvars e =     
+    let rec code_gen env_size_counter e =
+      let code_gen_same_counter = code_gen env_size_counter in
+      match e with 
+      | Const'(c) -> 
+        let gen_const c = 
+          let (i, s) = List.assoc c consts in
+          "mov rax, const_tbl+" ^ string_of_int i ^ "\n" in
+        gen_const c
+      | Var'(VarParam(name, minor)) -> 
+        "mov rax, qword [rbp + 8 * (4 + " ^ (string_of_int minor) ^ ")]" ^ " \n"
+      | Set'((VarParam(name, minor)), e) ->
+        code_gen_same_counter e ^ 
+        "mov qword [rbp + 8 * (4 +" ^ (string_of_int minor) ^ ")], rax
+         mov rax, SOB_VOID_ADDRESS" ^ "\n"
+      | Var'(VarBound(name, major, minor)) -> 
+        "mov rax, qword [rbp + 8 * 2]
+         mov rax, qword [rax + 8 * " ^ (string_of_int major) ^ "]
+         mov rax, qword [rax + 8 * " ^ (string_of_int minor) ^ "]\n"
+      | Set'((VarBound(name, major, minor)), e) ->
+        code_gen_same_counter e ^ 
+        "mov rbx, qword [rbp + 8 * 2]
+         mov rbx, qword [rbx + 8 * "^ (string_of_int major) ^ "]
+         mov qword [rbx + 8 * "^ (string_of_int minor) ^ "], rax
+         mov rax, SOB_VOID_ADDRESS \n"
+      | Var'(VarFree(s)) -> 
+        "mov rax, qword [fvar_tbl + " ^ (string_of_int (List.assoc s fvars)) ^ "]\n"
+      | Set'(VarFree(s), e) ->
+        code_gen_same_counter e ^
+        "mov qword [fvar_tbl + " ^ (string_of_int (List.assoc s fvars)) ^ "], rax
+         mov rax, SOB_VOID_ADDRESS\n"
+      | Seq'(lst) -> 
+        String.concat "" (List.map code_gen_same_counter lst)   
+      | If'(test, dit, dif) ->
+        let str_counter = string_of_int (inc_and_get_counter if_counter) in
+        code_gen_same_counter test ^
+        "cmp rax, SOB_FALSE_ADDRESS\n" ^
+        "je Lelse" ^ str_counter ^ "\n" ^
+        code_gen_same_counter dit ^
+        "jmp IfExit" ^ str_counter ^
+        "\nLelse" ^ str_counter ^ ":\n" ^
+        code_gen_same_counter dif ^ "\n" ^
+        "IfExit" ^ str_counter ^ ":\n"
+      | Or'(lst) ->  
+        let str_counter = string_of_int(inc_and_get_counter or_counter) in
+        let jump =
+        "cmp rax, SOB_FALSE_ADDRESS
+         jne OrExit" ^ str_counter ^"\n" in
+        let concatend = String.concat jump (List.map code_gen_same_counter lst) in
+        concatend ^ "OrExit" ^ str_counter ^ ":\n"
+
+      | Box'(v) ->
+        (code_gen_same_counter (Var'(v))) ^ 
+        "MALLOC rbx,WORD_SIZE
+        mov [rbx], rax
+        mov rax, rbx\n"
+      | BoxGet'(VarFree(s)) ->
+        code_gen_same_counter (Var'(VarFree(s)))
+      | BoxGet'(v) ->
+        (code_gen_same_counter (Var'(v))) 
+        ^ "mov rax, qword [rax]\n" 
+      | BoxSet'(v, e) ->
+        (code_gen_same_counter e) ^
+        "push rax \n"^
+        (code_gen_same_counter(Var'(v))) ^
+        "pop qword [rax]
+         mov rax, SOB_VOID_ADDRESS\n"
+      | Def'(VarFree(s), e) ->
+        code_gen_same_counter e ^
+        "mov qword [fvar_tbl + " ^ (string_of_int (List.assoc s fvars)) ^ "], rax
+        mov rax, SOB_VOID_ADDRESS"
+      | LambdaSimple'(args, body) ->
+        let env_size_counter_str = (string_of_int (env_size_counter+1)) in
+        let num_of_args_str = string_of_int (List.length args) in
+        let lambda_counter_str = string_of_int(inc_and_get_counter lambda_counter) in
+        let lambda_body =
+          "lambda_code_"^lambda_counter_str ^":
+           enter 0,0           
+           mov rax, "^num_of_args_str ^"    ; rax <- num of args known from the expr'
+           cmp rax, PARAM_COUNT              ; PARAM_COUNT = qword [rbp + 3*8]
+           "^ code_gen (env_size_counter+1) body ^
+           "leave
+           ret
+           " 
+           in
+        
+
+         "mov r13, "^env_size_counter_str^
+         "\nMALLOC rbx, ("^env_size_counter_str^" * WORD_SIZE) 			; rbx <- vector of size extEnv*WS
+         
+         EXT_ENV              ; rbx <- extEnv\n
+         MAKE_CLOSURE (rax, rbx, lambda_code_"^lambda_counter_str^")
+         jmp end_lambda_body_"^lambda_counter_str ^ "\n"
+         ^lambda_body^"
+         end_lambda_body_"^lambda_counter_str ^ ":\n"
+
+      | Applic'(proc, args)->
+        let generateArgs = (List.fold_left(fun acc curr -> "" ^ (code_gen_same_counter curr)^"push rax \n"^ acc)"" args) in
+
+        let n = (string_of_int (List.length args)) in
+        
+        let procVal = (code_gen_same_counter proc) ^ "
+          push qword [rax + TYPE_SIZE]
+          call [rax + TYPE_SIZE + WORD_SIZE]
+
+          add rsp, 8*1      ; pop env
+          pop rbx           ; pop arg count
+          inc rbx           ; for the magic
+          shl rbx, 3        ; rbx = rbx * 8
+          add rsp, rbx      ; pop args\n" in
+
+        "push SOB_NIL_ADDRESS\n" ^ generateArgs ^ "push "^n ^ "\n" ^ procVal
+
+      | ApplicTP'(proc, args)->
+        let generateArgs = (List.fold_left(fun acc curr -> "" ^ (code_gen_same_counter curr)^"push rax \n"^ acc)"" args) in
+
+        let n = (string_of_int (List.length args)) in
+        
+        
+        let procVal = (code_gen_same_counter proc) ^ "
+          mov rsi, rax
+          CLOSURE_ENV rcx, rsi
+          push rcx
+
+          push qword [rbp + 8 * 1] ; old ret addr
+          mov rdx,[rbp]             ; save the old rbp
+
+          mov rdi, "^n^" 
+          add rdi,5
+
+          mov rax, [rbp+8*3] 
+          add rax, 5     
+          mov r11, -8
+          mov rbx, rax
+          mov rcx,1
+          
+        .rep:
+         cmp rdi,rcx
+         je .endRep
+  	     dec rax
+         
+         mov r13, [rbp+r11]
+         add r11, -8
+         mov qword [rbp+WORD_SIZE*rax], r13
+         inc rcx
+         jmp .rep
+       .endRep:
+         dec rdi
+         sub rbx, rdi
+         mov rdi, rdx
+         shl rbx, 3
+         mov rsp,rbp                
+         add rsp, rbx
+  
+         mov rbp,rdi         
+         jmp [rsi + TYPE_SIZE + WORD_SIZE]
+         " in
+
+        ";----------------------ApplicTP-------------------
+        push SOB_NIL_ADDRESS\n" ^ generateArgs ^"push qword " ^ n ^ "\n" ^ procVal
+      
+      | LambdaOpt'(args, arg, body) ->
+        let env_size_counter_str = (string_of_int (env_size_counter+1)) in
+        let minimum_args_expacted = string_of_int (List.length args) in
+        let lambda_counter_str = string_of_int(inc_and_get_counter lambda_counter) in
+        let iteration_number_on_shifting = string_of_int ((List.length args)+3) in
+        let adjusting_frame =
+          "lambda_code_"^lambda_counter_str ^":
+            mov r15, rsp           ; backup rsp
+
+            mov r10, [r15]
+            mov rax, "^minimum_args_expacted ^"    ; rax <- num of args known from the expr'
+            cmp rax, qword [r15+8*2]             ; where argc is right now
+            je use_magic"^ lambda_counter_str ^ "
+
+            ;; otherwise, we have args to pack and we need to shift the frame:
+            mov r8, qword [r15+8*2] 
+            sub r8, "^minimum_args_expacted^"
+            mov r9, qword [r15+8*2] 
+            add r9, 2
+            PACK_OPT_ARGS r8, r9, "^minimum_args_expacted^"
+            sub r8, 1
+            ADJUST_FRAME r8, "^iteration_number_on_shifting^"            
+            mov qword [r15+8*2] , ("^minimum_args_expacted^"+1)
+            jmp end_frame_adjust_"^lambda_counter_str ^"
+
+            ;; no need to shift the frame
+            use_magic"^ lambda_counter_str ^":
+            end_frame_adjust_"^lambda_counter_str^":
+            mov rsp, r15            
+            "         
+          in
+        let lambda_body = 
+          "push rbp
+          mov rbp, rsp\n"
+          ^ code_gen (env_size_counter+1) body ^"
+          leave
+          ret
+          " 
+           in
+
+        "mov r13, "^env_size_counter_str^
+        "\nMALLOC rbx, ("^env_size_counter_str^" * WORD_SIZE) 			; rbx <- vector of size extEnv*WS
+        
+        EXT_ENV              ; rbx <- extEnv\n
+        MAKE_CLOSURE (rax, rbx, lambda_code_"^lambda_counter_str^")
+        jmp end_lambda_body_"^lambda_counter_str ^ "\n"
+        ^adjusting_frame ^
+        lambda_body ^
+        "end_lambda_body_"^lambda_counter_str ^ ":\n"
+      | _ -> ""
+  
+    in
+    code_gen 0 e;;
+    
 end;;
 
+
+
+
+
+
+
+
diff --git a/compiler.ml b/compiler.ml
index fbf0ad5..c92b981 100644
--- a/compiler.ml
+++ b/compiler.ml
@@ -35,6 +35,7 @@ let make_prologue consts_tbl fvars_tbl =
     (* Additional rational numebr ops *)
     "numerator", "numerator"; "denominator", "denominator"; "gcd", "gcd";
     (* you can add yours here *)
+    "apply", "apply"; "car", "car"; "cons", "cons"; "cdr", "cdr"; "set-car!", "set_car"; "set-cdr!", "set_cdr";
   ] in
   let make_primitive_closure (prim, label) =
     (* This implementation assumes fvars are addressed by an offset from the label `fvar_tbl`.
diff --git a/compiler.s b/compiler.s
index fb7d307..7478d4f 100644
--- a/compiler.s
+++ b/compiler.s
@@ -63,6 +63,117 @@
 	sub %1, [rsp]
 	add rsp, 8
 %endmacro
+
+%define PARAM_COUNT qword [rbp+3*WORD_SIZE]
+
+%define SHIFT_PARAM PARAM_COUNT+5
+; on enterance rbx <- vector of size extEnv*WS
+; r13 <- extEnvSize
+; on exit: rbx <- updated extEnv 
+%macro EXT_ENV 0
+	mov rcx, PARAM_COUNT	; rcx <- argc
+	inc rcx					; for the magic
+	shl rcx, 3				; rcx <- rcx*WORD_SIZE
+	MALLOC rdx, rcx			; rdx <- vector of size argc*WS, newParamVector
+	mov [rbx], rdx			; extEnv[0] <- rdx
+	
+	mov r9, PARAM_COUNT		; r9 <- argc
+	inc r9					; for the magic
+	mov rcx, 0				; rcx is the running index
+%%create_param_vector_loop:	
+	cmp rcx, r9								; if index == argc -->> end of params (no param of index [argc])
+	je %%end_param_loop
+
+	add rcx, 4							
+	lea r10, [rbp + WORD_SIZE * rcx]
+	mov r10, [r10]							; r10 <- param num. rcx 
+	sub rcx, 4
+	mov [rdx + (WORD_SIZE * rcx)], r10			; newParamVector[rcx] <- r10
+	add rcx, 1
+	jmp %%create_param_vector_loop
+
+%%end_param_loop:	
+	mov r12, qword [rbp +WORD_SIZE * 2]		; r12 <- pointer of currEnv 
+	sub r13, 1								; currEnvSize == extEnvSize -1
+	mov rcx, r13							; rcx <- (currEnv size)
+%%copy_pointers_from_env_to_extenv_loop:
+	cmp rcx, 0
+	jz %%end
+	mov r8, rcx					; r8 <- currEnvSize- number of arguments that were copied
+	sub r8, 1 					; r8 <- the running index of the currEnv
+	lea r11, [r12 + r8*WORD_SIZE]
+	mov r11, [r11]					; r11 <- address of currEnv[r8]
+	;mov r11, [r12 + r8*WORD_SIZE]	; r11 <- address of currEnv[r8]
+	add r8, 1
+	mov [rbx + WORD_SIZE * r8] , r11	;extEnv[r8+1] <- currEnv[r8]
+	sub rcx, 1						; loop with r8-1
+	jmp %%copy_pointers_from_env_to_extenv_loop	
+%%end:
+
+%endmacro
+
+%macro SHIFT_FRAME 1 
+; %1 = size of frame(constant)
+	push rax
+	mov rax, PARAM_COUNT
+	add rax, 5
+	shl rcx, 3
+	mov rcx, rax			; rcx <- (PARAM_COUNT+5)*WORD_SIZE in order to inc the rdp later
+%assign i 1
+%rep %1
+	dec rax
+	push qword [rbp-i*WORD_SIZE]
+	pop qword [rbp+rax*WORD_SIZE]
+%assign i i+1
+%endrep
+	pop rax
+	add rsp, rcx		; inc the rsp to the new frame
+%endmacro
+
+%define PARAM_COUNT_OPT qword [rbp+WORD_SIZE*2]
+
+; %1 number of args need to be packed 
+; %2 the vector offset (one before magic)
+; %3 number of minimum args (constant)
+%macro PACK_OPT_ARGS 3
+	mov rcx, 0
+	mov rdx, SOB_NIL_ADDRESS
+	%%pack_loop:
+		cmp rcx, %1
+		je %%end_pack_loop
+		
+		mov r11, %2
+		sub r11, rcx
+
+		lea r10, [r15 + WORD_SIZE*r11]		; last arg is first
+		mov r10, [r10]
+
+		MAKE_PAIR (rbx, r10, rdx)
+		mov rdx, rbx
+		
+		inc rcx
+		jmp %%pack_loop
+	%%end_pack_loop:	
+	lea r10, [r15 + WORD_SIZE * %2]
+	mov qword [r10], rbx					; last legal arg on stack <- pointer to args vector
+	
+%endmacro
+
+; %1 shifting amount - number of args packed-1
+; %2-1 offset of first arg to shift - A[n] (= minimum args+3) (constant)
+; shifting the rest of the frame (below the vector) %1*WS up
+%macro ADJUST_FRAME 2
+	%assign i %2-1
+	%%loopi:
+	%rep %2
+		mov r12, qword [r15 + WORD_SIZE*i]		
+		lea r11, [r15 + WORD_SIZE*(i + %1)] 
+		mov qword [r11], r12
+	%assign i i-1
+	%endrep
+	shl %1, 3
+	add r15, %1				; shifting rsp up
+%endmacro
 	
 ; Creates a short SOB with the
 ; value %2
@@ -138,7 +249,25 @@
 %define MAKE_CLOSURE(r, env, body) \
         MAKE_TWO_WORDS r, T_CLOSURE, env, body
 
-	
+%macro MAKE_LITERAL 2 
+;Make a literal of type %1; followed by the definition %2
+	db %1
+	%2
+%endmacro
+
+%define MAKE_LITERAL_FLOAT(val) MAKE_LITERAL T_FLOAT, dq val
+%define MAKE_LITERAL_CHAR(val) MAKE_LITERAL T_CHAR, db val
+%define MAKE_LITERAL_SYMBOL(val) MAKE_LITERAL T_SYMBOL, dq val
+
+%macro MAKE_LITERAL_STRING 1
+	db T_STRING
+	dq (%%end_str - %%str)
+	%%str:
+	db %1
+	%%end_str:
+%endmacro
+
+
 ;;; Macros and routines for printing Scheme OBjects to STDOUT
 %define CHAR_NUL 0
 %define CHAR_TAB 9
@@ -207,7 +336,7 @@ write_sob_float:
 	mov rax, 1
 
 	;; printf-ing floats (among other things) requires the stack be 16-byte aligned
-	;; so align the stack *downwards* (take up some extra space) if needed before
+	;; so align the stack downwards (take up some extra space) if needed before
 	;; calling printf for floats
 	and rsp, -16 
 	call printf
diff --git a/prims.ml b/prims.ml
index 89ee1ab..3e7724f 100644
--- a/prims.ml
+++ b/prims.ml
@@ -10,7 +10,7 @@
    However, adding correctness-checking and error handling *as general templates* would be
    rather simple.
  *)
-module type PRIMS = sig
+ module type PRIMS = sig
   val procs : string;;
 end
 
@@ -56,8 +56,6 @@ module Prims : PRIMS = struct
      The argument register assignment follows the x86 64bit Unix ABI, because there needs to be *some*
      kind of consistency, so why not just use the standard ABI.
      See page 22 in https://raw.githubusercontent.com/wiki/hjl-tools/x86-psABI/x86-64-psABI-1.0.pdf
-
-     *** FIXME: There's a typo here: PVAR(0) should be rdi, PVAR(1) should be rsi, according to the ABI     
    *)
   let make_unary label body = make_routine label ("mov rsi, PVAR(0)\n\t" ^ body);;
   let make_binary label body = make_unary label ("mov rdi, PVAR(1)\n\t" ^ body);;
@@ -86,30 +84,6 @@ module Prims : PRIMS = struct
         (return_boolean_eq ("mov sil, byte [rsi]\n\tcmp sil, " ^ type_tag)) in
     String.concat "\n\n" (List.map (fun (a, b) -> single_query a b) queries_to_types);;
 
-  (* The rational number artihmetic operators have to normalize the fractions they return,
-     so a GCD implementation is needed. Now there are two options: 
-     1) implement only a scheme-procedure-like GCD, and allocate rational number scheme objects for the 
-        intermediate numerator and denominator values of the fraction to be returned, call GCD, decompose
-        the returned fraction, perform the divisions, and allocate the final fraction to return
-     2) implement 2 GCDs: a low-level gcd that only implements the basic GCD loop, which is used by the rational 
-        number arithmetic operations; and a scheme-procedure-like GCD to be wrapped by the stdlib GCD implementation.
-    
-     The second option is more efficient, and doesn't cost much, in terms of executable file bloat: there are only 4
-     routines that inline the primitive gcd_loop: add, mul, div, and gcd.
-     Note that div the inline_gcd embedded in div is dead code (the instructions are never executed), so a more optimized
-     version of prims.ml could cut the duplication down to only 3 places (add, mul, gcd).
-   *)
-  let inline_gcd =
-    ".gcd_loop:
-     and rdi, rdi
-     jz .end_gcd_loop
-     cqo
-     idiv rdi
-     mov rax, rdi
-     mov rdi, rdx
-     jmp .gcd_loop	
-     .end_gcd_loop:";;
-
   (* The arithmetic operation implementation is multi-tiered:
      - The low-level implementations of all operations are binary, e.g. (+ 1 2 3) and (+ 1) are not 
        supported in the low-level implementation.
@@ -154,8 +128,7 @@ module Prims : PRIMS = struct
        and not 64 bits.
      - `lt.flt` does not handle NaN, +inf and -inf correctly. This allows us to use `return_boolean jl` for both the
        floating-point and the fraction cases. For a fully correct implementation, `lt.flt` should make use of
-       the `ucomisd` opcode and `return_boolean jb` instead (see https://www.felixcloutier.com/x86/ucomisd for
-       more information).
+       `return_boolean jb` instead (see https://www.felixcloutier.com/x86/ucomisd for more information).
    *)
   let numeric_ops =
     let numeric_op name flt_body rat_body body_wrapper =      
@@ -197,23 +170,6 @@ module Prims : PRIMS = struct
 	  NUMERATOR rsi, rsi
 	  NUMERATOR rdi, rdi
           " ^ rat_op ^ "
-	  mov rax, rcx
-	  mov rdi, rsi
-          " ^ inline_gcd ^ "
-	  mov rdi, rax
-	  mov rax, rsi
-	  cqo
-	  idiv rdi
-	  mov rsi, rax
-	  mov rax, rcx
-	  cqo
-	  idiv rdi
-	  mov rcx, rax
-          cmp rcx, 0
-          jge .make_rat
-          imul rsi, -1
-          imul rcx, -1
-          .make_rat:
           MAKE_RATIONAL(rax, rsi, rcx)") in
     let comp_map = [
         (* = *)
@@ -244,8 +200,8 @@ module Prims : PRIMS = struct
 	 FLOAT_VAL rdi, rdi
 	 movq xmm1, rdi
 	 cmpltpd xmm0, xmm1
-         movq rsi, xmm0
-         cmp rsi, 0", "lt";
+	 movq rsi, xmm0
+	 cmp rsi, 0", "lt";
       ] in
     let comparator comp_wrapper name flt_body rat_body = numeric_op name flt_body rat_body comp_wrapper in
     (String.concat "\n\n" (List.map (fun (a, b, c) -> arith c b a (fun x -> x)) arith_map)) ^
@@ -340,14 +296,143 @@ module Prims : PRIMS = struct
         "xor rdx, rdx
 	 NUMERATOR rax, rsi
          NUMERATOR rdi, rdi
-         " ^ inline_gcd ^ "
+       .loop:
+	 and rdi, rdi
+	 jz .end_loop
+	 xor rdx, rdx 
+	 div rdi
+	 mov rax, rdi
+	 mov rdi, rdx
+	 jmp .loop	
+       .end_loop:
 	 mov rdx, rax
-         cmp rdx, 0
-         jge .make_result
-         neg rdx
-         .make_result:
          MAKE_RATIONAL(rax, rdx, 1)", make_binary, "gcd";  
-      ] in
+
+  
+    (* apply *)
+    "
+    mov r12, PARAM_COUNT        ; [rbp+3*WORD_SIZE], argc from first frame
+    dec r12                     ; miinus one
+    mov r11, PVAR(r12)          ; in that index there is a pointer to a list
+    mov rcx, 0                  ; 
+    push SOB_NIL_ADDRESS
+
+    .isList:
+    cmp r11, SOB_NIL_ADDRESS    ; cmp the list pointer to nil
+    je .emptyList               ; 
+    mov r13, [r11 + TYPE_SIZE]  ; load the element to r13
+    push qword r13              ; push var from list
+    mov r11, [r11 + TYPE_SIZE + WORD_SIZE]    ; move cdr to r11
+    inc rcx                     ; 
+    jmp .isList                 ; 
+
+    .emptyList:
+    mov r13, 0                  ;index from above list. rsp + r13
+    mov r14, rcx ;              ;index from botuom list. 
+    dec r14 
+
+    .swap:
+    cmp r13, r14
+    jge .finishSwap
+    mov r12, [rsp + r13 * WORD_SIZE]
+    mov r15, [rsp + r14 * WORD_SIZE]
+    mov [rsp + r14 * WORD_SIZE], r12
+    mov [rsp + r13 * WORD_SIZE], r15
+
+    inc r13 
+    dec r14 
+    jmp .swap
+    
+
+    .finishSwap:
+    mov r11, PARAM_COUNT
+    sub r11, 2
+    .pushArgs:
+    cmp r11, 0
+    je .finishPushArgs
+    push PVAR(r11)
+    dec r11
+    jmp .pushArgs
+
+    .finishPushArgs:
+    add rcx, PARAM_COUNT
+    sub rcx, 2
+    push rcx
+
+    mov r11 ,PVAR(0) 
+    CLOSURE_ENV r12 ,r11
+    push r12
+    CLOSURE_CODE r9 ,r11
+    
+    ;break:
+
+    ; mov rsi, rax
+    ;CLOSURE_ENV rcx, rsi
+    ;push rcx
+
+    push qword [rbp + 8 * 1]  ; old ret addr
+    mov rdx,[rbp]             ; save the old rbp
+
+    mov rdi, rcx              ; save number of arguments
+    add rdi,5                 ; rdi set to length of first frame
+
+    mov rax, [rbp+8*3]        ; number of parameters of second frame
+    add rax, 5                ; add 5 to rax
+    mov r11, -8               ; init r11 with -8
+    mov rbx, rax              ; rax = length of second frame. into rbx
+    mov rcx,1                 ;
+    
+  .rep:
+    cmp rdi,rcx               ; compare rdi with rcx
+    je .endRep                ; if rdi cmp rcx -> endrep
+    dec rax                   ; dec rax as the cell that copied
+    
+    mov r13, [rbp+r11]        ; call from first frame to r13
+    add r11, -8               ; decrease r11 with -8
+    mov qword [rbp+WORD_SIZE*rax], r13 ; set r13 value into the second frame
+    inc rcx                   ; increment rcx till rdi
+    jmp .rep                  ; loop
+  .endRep:
+    dec rdi
+    sub rbx, rdi              ; calculate the sidstance in negative
+    mov rdi, rdx              ; save old_rbx to rdi
+    shl rbx, 3
+    mov rsp,rbp                
+    add rsp, rbx
+
+    ;check:
+    mov rbp,rdi         
+    
+    jmp r9
+    ", make_routine ,"apply";
+
+      (* car *)
+      "
+      CAR rax, rsi
+      " , make_unary, "car";
+
+      (* cons *)
+      "
+      MAKE_PAIR (rax, rsi, rdi)
+      ", make_binary, "cons";
+
+      (* cdr *)
+      "
+      CDR rax, rsi
+      ", make_unary, "cdr";
+
+      (* set-cdr! *)
+      "
+      mov [rsi + TYPE_SIZE + WORD_SIZE], rdi
+      mov rax, SOB_VOID_ADDRESS
+      ", make_binary, "set_cdr";
+
+      (* set-car! *)
+      "
+      mov [rsi + TYPE_SIZE], rdi
+      mov rax, SOB_VOID_ADDRESS
+      ", make_binary, "set_car"
+        ] in
     String.concat "\n\n" (List.map (fun (a, b, c) -> (b c a)) misc_parts);;
 
   (* This is the interface of the module. It constructs a large x86 64-bit string using the routines
diff --git a/reader.ml b/reader.ml
index 32445c2..2c99f66 100644
--- a/reader.ml
+++ b/reader.ml
@@ -1,6 +1,6 @@
-
+  
 #use "pc.ml";;
-
+open PC;;
 exception X_not_yet_implemented;;
 exception X_this_should_not_happen;;
   
@@ -30,7 +30,8 @@ let rec sexpr_eq s1 s2 =
   | _ -> false;;
 
 module Reader: sig
-  val read_sexprs : string -> sexpr list
+  val read_sexprs : string -> sexpr list 
+
 end
 = struct
 let normalize_scheme_symbol str =
@@ -40,7 +41,186 @@ let normalize_scheme_symbol str =
 	s) then str
   else Printf.sprintf "|%s|" str;;
 
+  (**
+  val read_sexpr: string -> sexpr 
+  let read_sexprs string = raise X_not_yet_implemented;;
+  let read_sexpr string = raise X_not_yet_implemented;;
+  end;
 
-let read_sexprs string = raise X_not_yet_implemented;;
-  
-end;; (* struct Reader *)
+  *)
+
+
+(***************bool******************)
+
+let bool_true = pack (caten (char '#') (char_ci 't')) (fun _-> Bool(true));;
+let bool_false = pack (caten (char '#') (char_ci 'f')) (fun _->Bool(false));;
+let nt_bool =disj bool_true bool_false ;;
+
+(***************Char******************)
+
+let char_prefix = caten (char '#') (char '\\');;
+let visible_simple_char = pack (const(fun ch1 -> ch1 > ' ')) (fun ch -> Char(ch));;
+let named_char =  pack (disj_list [word_ci "newline";
+                                  word_ci "nul";
+                                  word_ci "page";
+                                  word_ci "return";
+                                  word_ci "space";
+                                  word_ci "tab"])
+(fun charlist  ->  
+match (list_to_string (List.map (fun (ch) -> (lowercase_ascii ch)) charlist)) with 
+  | "newline" -> Char (Char.chr 10)
+  | "nul" -> Char (Char.chr 0)
+  | "tab" -> Char (Char.chr 9)
+  | "space" -> Char (Char.chr 32)
+  | "return" -> Char (Char.chr 13)
+  | "page" ->  Char (Char.chr 12)
+  |_ -> raise X_this_should_not_happen);;
+  let nt_char = pack (caten char_prefix (disj named_char visible_simple_char)) (fun ((_,_),c3) -> c3);;
+
+
+(**************symbol******************)
+  let nt_dot = char '.';;
+  let nt_symbol_char_not_dot = 
+    let digit = range '0' '9' in
+    let nt_low = range 'a' 'z' in
+    let nt_up =  pack (range 'A' 'Z') (fun ch-> lowercase_ascii ch)  in
+    let nt_punctuation = one_of "!$^*-=+_<>?/:" in
+  let nt = disj_list [nt_low; nt_up; nt_punctuation; digit] in nt;;
+
+  let nt_symbol_char = disj nt_dot nt_symbol_char_not_dot ;; 
+  let nt_symbol =  disj (pack (caten nt_symbol_char (plus nt_symbol_char))
+  (fun (ch,l)-> Symbol(list_to_string ([ch]@l))))
+  (pack nt_symbol_char_not_dot (fun (ch)-> Symbol(list_to_string [ch])));;
+
+(**************string******************)
+
+(**when i need to use nt ? and how can i call to string parser?*)
+(**what is the meaning of () and where can i need to skip and ch!='\'*)
+
+let nt_string_literal_char = const (fun (ch) -> ch <> '\\' && ch <> '"');;
+
+let nt_string_meta_char = pack ( disj_list [(caten (char '\\') (char_ci '\\')); (caten (char '\\') (char_ci '\"')); (caten (char '\\') (char_ci 't'));
+(caten (char '\\') (char_ci 'f'));(caten (char '\\') (char_ci 'n')) ; (caten (char '\\') (char_ci 'r'))])
+(fun (bslas,ch)-> 
+  match (lowercase_ascii ch) with
+  | '\\' -> (char_of_int 92) 
+  | '\"' -> (char_of_int 34) 
+  | 't'  -> (char_of_int 9)
+  | 'f'  -> (char_of_int 12) 
+  | 'n'  -> (char_of_int 10)
+  | 'r'  -> (char_of_int 13)
+  | _ -> raise X_no_match);;
+
+let nt_string_char = disj nt_string_literal_char nt_string_meta_char;;
+let nt_string = pack (caten (char '"') (caten (star nt_string_char) (char '"'))) 
+(fun ((_,(ch2,_)))-> String (list_to_string ch2));;
+
+(*************numbers*****************)
+let nt_digit = pack (range '0' '9') (fun (ch)-> int_of_char ch - 48);;
+let nt_natural = plus nt_digit ;;
+let nt_integer = pack (caten (maybe (disj (char '+') (char '-'))) nt_natural) 
+(fun (sign,num)-> 
+let num =(List.fold_left(fun curr acc -> 10 * curr + acc) 0 num)
+in match sign with 
+| Some('+') -> Number(Fraction(num,1))
+| Some('-')-> Number(Fraction(-1*num,1))
+| None -> Number(Fraction(num,1))
+| _ -> raise X_this_should_not_happen);;
+
+let nt_digit1 = pack (range '0' '9') (fun (ch)-> float_of_int (int_of_char ch - 48));;
+let nt_natural1 = plus nt_digit1;;
+
+let nt_float = pack (caten nt_integer (caten nt_dot nt_natural1))
+(fun (numeration,(dot,denomerator))->
+match numeration with 
+| Number(Fraction(numeration,1)) -> Number(Float( (float_of_int (numeration) ) +. (List.fold_right (fun a b-> (a+.b)/.10.0) denomerator 0.0)))
+| _ -> raise X_this_should_not_happen);;
+
+
+let rec gcd a b =
+  if b = 0 then a else gcd b (a mod b);;
+
+let nt_fraction = pack (caten nt_integer (caten (char '/') nt_natural))
+(fun (numeration,(backs,denomerator))->
+match numeration with 
+| Number(Fraction(numeration,1)) -> let crate_num = (List.fold_left(fun curr acc -> 10 * curr + acc) 0 denomerator) in
+                                    let gcdr = (gcd numeration crate_num) in
+                                    if(gcdr>0) then Number(Fraction(numeration/gcdr,crate_num/gcdr)) else 
+                                    if(gcdr=0) then Number(Fraction(numeration,crate_num)) else
+                                    Number(Fraction(numeration/(-1*gcdr),crate_num/(-1*gcdr)))
+| _ -> raise X_this_should_not_happen);;
+
+
+let nt_scientific_notation = pack (caten (disj nt_float nt_integer) (caten (char_ci 'e') nt_integer) )
+(fun (num1,(e,num2))-> match num1,num2 with 
+| Number(Float(num1)),Number(Fraction(num2,1))-> Number(Float(num1*.10.0** (float_of_int num2)))
+| Number(Fraction(num1,1)),Number(Fraction(num2,1)) -> Number(Float((float_of_int num1) *.10.0** (float_of_int num2)))
+| _ -> raise X_this_should_not_happen);;
+
+let nt_number = disj_list [nt_scientific_notation;nt_fraction;nt_float;nt_integer];;
+
+
+(*************List***************)
+
+let nt_whitespaces_star = star(const (fun ch -> ch <= ' '));;
+
+let make_paired nt_left nt_right nt =
+  let nt = caten nt_left nt in
+  let nt = pack nt (function (_, e) -> e) in
+  let nt = caten nt nt_right in
+  let nt = pack nt (function (e, _) -> e) in
+  nt;;
+
+(***************LineComments******************)
+let nt_comm = 
+  let nt = (disj (char '\n') 
+                 (pack
+                 nt_end_of_input
+                 (fun e-> '\n'))) in
+  let nt=caten (caten (char ';')  (star (diff nt_any nt))) nt in 
+  pack nt (fun _ -> []) 
+
+let rec nt_sexpr s = pack (caten (star (disj_list [nt_comm;plus nt_whitespace;nt_sexp_comm])) 
+(caten (disj_list [nt_dotted_list;nt_bool;nt_char;(not_followed_by (nt_number) (nt_symbol));nt_string;nt_symbol;nt_list;nt_quoted;nt_q_quoted;nt_un_spliced_quoted;nt_un_quoted]) (star (disj_list [plus nt_whitespace;nt_sexp_comm;nt_comm]))))
+(fun (_,(sexp,_))-> sexp) s
+
+and nt_list s = (pack (make_paired (char '(') (char ')') (star nt_sexpr))
+        (fun e -> 
+        (List.fold_right 
+        (fun curr acc -> Pair (curr , acc))
+        e
+        Nil))) s
+
+ and nt_dotted_list s =  pack (caten (char '(') (caten (plus nt_sexpr) 
+ (caten nt_dot (caten nt_sexpr  (char ')') ) ) ) ) 
+        (fun (p1,(plus_spex,(dot,(spex,p2))))-> 
+        (List.fold_right 
+        (fun curr acc -> Pair (curr , acc))
+        plus_spex
+        spex)) s 
+
+  and nt_quoted s = pack (caten (char '\'') (nt_sexpr)) (fun (a, sex) -> Pair(Symbol("quote"),Pair(sex,Nil))) s
+  and nt_q_quoted s = pack (caten (char '`') (nt_sexpr)) (fun (a, sex) -> Pair(Symbol("quasiquote"),Pair(sex,Nil))) s
+  and nt_un_quoted s = pack (caten (char ',') (nt_sexpr)) (fun (a, sex) -> Pair(Symbol("unquote"),Pair(sex,Nil))) s
+  and nt_un_spliced_quoted s = pack (caten (word ",@") (nt_sexpr)) (fun (a, sex) -> Pair(Symbol("unquote-splicing"),Pair(sex,Nil))) s
+
+   and nt_sexp_comm s = 
+    let nt = (pack 
+               (caten (word "#;") nt_sexpr)
+               (fun _ -> [])) in
+     let nt= (disj nt
+                   (pack 
+                  (caten (caten (word "#;") nt_sexp_comm) nt_sexpr)
+                  (fun _ -> []))) in
+    pack nt (fun _ -> []) s 
+
+let read_sexprs string = (fun (str) -> let (slist, _) =  ((star nt_sexpr) (string_to_list str)) in slist) string;;
+end;;
+
+(* open Reader;;
+read_sexprs "(let ((baf (lambda (f)
+(lambda (n)
+  (if (> n 0)
+      `(* ,n ,((f f) (- n 1)))
+      \"end\")))))
+((baf baf) 1))" *)
diff --git a/readme.txt b/readme.txt
index e69de29..e36a0bf 100644
--- a/readme.txt
+++ b/readme.txt
@@ -0,0 +1,7 @@
+We, Or Saar 205476369 and Daniel Levi 312534233 assert that the work we submitted is 100% our own. We have not received any
+part from any other student in the class, nor have we give parts of it for use to others.
+Nor have we used code from other sources: Courses taught previously at this university,
+courses taught at other universities, various bits of code found on the internet, etc.
+We realize that should our code be found to contain code from other sources, that a
+formal case shall be opened against us with vaג€™adat mishmaג€™at, in pursuit of disciplinary
+action.
diff --git a/semantic-analyser.ml b/semantic-analyser.ml
index 8e684f0..ef0da7d 100644
--- a/semantic-analyser.ml
+++ b/semantic-analyser.ml
@@ -28,15 +28,6 @@ let rec expr'_eq e1 e2 =
   | Var'(VarFree v1), Var'(VarFree v2) -> String.equal v1 v2
   | Var'(VarParam (v1,mn1)), Var'(VarParam (v2,mn2)) -> String.equal v1 v2 && mn1 = mn2
   | Var'(VarBound (v1,mj1,mn1)), Var'(VarBound (v2,mj2,mn2)) -> String.equal v1 v2 && mj1 = mj2  && mn1 = mn2
-  | Box'(VarFree v1), Box'(VarFree v2) -> String.equal v1 v2
-  | Box'(VarParam (v1,mn1)), Box'(VarParam (v2,mn2)) -> String.equal v1 v2 && mn1 = mn2
-  | Box'(VarBound (v1,mj1,mn1)), Box'(VarBound (v2,mj2,mn2)) -> String.equal v1 v2 && mj1 = mj2  && mn1 = mn2
-  | BoxGet'(VarFree v1), BoxGet'(VarFree v2) -> String.equal v1 v2
-  | BoxGet'(VarParam (v1,mn1)), BoxGet'(VarParam (v2,mn2)) -> String.equal v1 v2 && mn1 = mn2
-  | BoxGet'(VarBound (v1,mj1,mn1)), BoxGet'(VarBound (v2,mj2,mn2)) -> String.equal v1 v2 && mj1 = mj2  && mn1 = mn2
-  | BoxSet'(VarFree v1,e1), BoxSet'(VarFree v2, e2) -> String.equal v1 v2 && (expr'_eq e1 e2)
-  | BoxSet'(VarParam (v1,mn1), e1), BoxSet'(VarParam (v2,mn2),e2) -> String.equal v1 v2 && mn1 = mn2 && (expr'_eq e1 e2)
-  | BoxSet'(VarBound (v1,mj1,mn1),e1), BoxSet'(VarBound (v2,mj2,mn2),e2) -> String.equal v1 v2 && mj1 = mj2  && mn1 = mn2 && (expr'_eq e1 e2)
   | If'(t1, th1, el1), If'(t2, th2, el2) -> (expr'_eq t1 t2) &&
                                             (expr'_eq th1 th2) &&
                                               (expr'_eq el1 el2)
@@ -56,8 +47,9 @@ let rec expr'_eq e1 e2 =
   | ApplicTP'(e1, args1), ApplicTP'(e2, args2) ->
 	 (expr'_eq e1 e2) &&
 	   (List.for_all2 expr'_eq args1 args2)
-  | _ -> false;;	
-                      
+  | _ -> false;;
+	
+                       
 exception X_syntax_error;;
 
 module type SEMANTICS = sig
@@ -69,17 +61,297 @@ end;;
 
 module Semantics : SEMANTICS = struct
 
-let annotate_lexical_addresses e = raise X_not_yet_implemented;;
+let update_bounds prev_params bounds =
+  let updated_bounds = List.map(fun (name, major, minor)->(name, 1+major, minor))bounds in
+  let convert_bounds = List.map(fun (name, minor) -> (name, 0, minor)) prev_params in 
+  let new_bounds = List.append convert_bounds updated_bounds in new_bounds
+  ;;
+  
+let rec generate_params args idx =
+  match args with
+  | [] -> []
+  | first :: tail ->
+    let param = (first, idx) in
+    let tail_params = generate_params tail (idx+1) in
+    List.append [param] tail_params;;
+    
+(* let rec search_in_params name params =
+  Some(List.find (fun var -> fst var = name) params);;
+*)
+
+let rec search_in_params name params =
+    match params with
+    | [] -> None
+    | (v, mi) :: tail ->
+        if v = name then Some(v, mi) else search_in_params name tail;;
+
+(* let rec search_in_bounds name bounds =
+  Some(List.find (fun (var, major, minor) -> var=name) bounds);; *)        
+
+let rec search_in_bounds name bounds =
+  match bounds with
+  | [] -> None
+  | (v, ma, mi) :: tail ->
+      if v = name then Some((v, ma, mi)) else search_in_bounds name tail;;
+  
+let create_variable name params bounds =
+  let p_value = search_in_params name params in
+  match p_value with
+  | Some((v, mi)) -> VarParam(v, mi)
+  | _ ->
+    ( let bound_val = search_in_bounds name bounds in 
+        match bound_val with    
+      | Some((v, ma, mi)) -> VarBound(v, ma, mi)
+      | _ -> VarFree(name));;
+  
+let to_params args =
+  let idx = 0 in
+  let params = generate_params args idx in 
+  params;;
+
+let rec lex_add e params bounds =
+  match e with
+  | Var(name) ->
+      let new_var = create_variable name params bounds in
+      Var'(new_var)
+
+  | Const(c) -> Const'(c)
+
+  | If(test, dit, dif)->
+      If'(lex_add test params bounds,
+          lex_add dit params bounds,
+          lex_add dif params bounds) 
+
+  | Set(Var(name), expr) ->
+      Set'(create_variable name params bounds,
+          lex_add expr params bounds)  
+
+  | Seq(exprs) -> 
+      let e = List.map (fun(expr) -> lex_add expr params bounds) exprs in
+      Seq'(e)   
+
+  | Or(exprs) ->
+      let e = List.map (fun(expr) -> lex_add expr params bounds) exprs in
+      Or'(e)  
+
+  | Def(Var(name), expr) ->
+      Def'(create_variable name params bounds,
+          lex_add expr params bounds)   
+  
+  | LambdaSimple(args, body) ->
+      let new_body = create_new_body args body params bounds in
+      LambdaSimple'(args, new_body)
+
+  | LambdaOpt(args, arg_opt, body) -> 
+      let total_args = List.append args [arg_opt] in
+      let new_body = create_new_body total_args body params bounds in 
+      LambdaOpt'(args, arg_opt, new_body)
+  
+  | Applic(rator, rands) ->
+      let new_rator = lex_add rator params bounds in
+      let new_rands = List.map (fun(rand) -> lex_add rand params bounds) rands in
+      Applic'(new_rator, new_rands)
+
+  | _ -> raise X_syntax_error
+      
+  
+  and create_new_body args body params bounds=
+    let updated_bounds = update_bounds params bounds in
+    let new_params = to_params args in
+    let new_body = lex_add body new_params updated_bounds in
+    new_body;;
+        
+    
+let annotate_lexical_addresses e = lex_add e [] []
+
+
+let rec annotate_tale_call_rec e in_tp = match e with
+      
+  (* if in_tp -> dit and dif are in TP *)
+  | If'(test, dit, dif) -> 
+      If'(test, annotate_tale_call_rec dit in_tp, annotate_tale_call_rec dif in_tp)
+
+  (* find the last expr. if in_tp -> last seq exprs is in TP *)
+  | Seq'(seq) ->
+      let new_seq = make_last_exps_TP seq in_tp in
+      Seq'(new_seq)
+
+  | Or'(lst) ->
+      let new_lst = make_last_exps_TP lst in_tp in
+      Or'(new_lst)
+
+  (*the body of set!/def is never in TP *)
+  | Set'(var, expr) -> Set'(var, annotate_tale_call_rec expr false)
+
+  | Def'(var, expr) -> Def'(var, annotate_tale_call_rec expr false)
+
+  (* every lambda has it's TC, therefor -> in_tp true *)
+  | LambdaSimple'(args, body) ->
+      LambdaSimple'(args, annotate_tale_call_rec body true)
+
+  | LambdaOpt'(args, arg_opt, body) ->
+      LambdaOpt'(args, arg_opt, annotate_tale_call_rec body true)
+
+  (* if in_tp -> ApplicTP' *)
+  | Applic'(rator, rands) ->
+    let new_rator = annotate_tale_call_rec rator false in
+    let new_rands = List.map (fun(rand) -> annotate_tale_call_rec rand false) rands in
+    if in_tp
+    then ApplicTP'(new_rator, new_rands)
+    else Applic'(new_rator, new_rands)
+  
+  | e -> e
+    
+  and make_last_exps_TP s in_tp = 
+  match s with
+    | [] -> raise X_syntax_error
+    | head :: tail -> 
+    (match tail with
+            | [] -> [annotate_tale_call_rec head in_tp]
+            | _ ->  List.append 
+                    [annotate_tale_call_rec head false]
+                    (make_last_exps_TP tail in_tp)
+    )
+;;
+                        
+
+let annotate_tail_calls e =  annotate_tale_call_rec e false;;
+
 
-let annotate_tail_calls e = raise X_not_yet_implemented;;
 
-let box_set e = raise X_not_yet_implemented;;
+(* params = vars list, args = new vars (strings) *)
+let rec handle_args args params =
+  match params with  
+  | VarParam(name, minor) :: tail ->
+      if(List.mem name args)
+      then handle_args args tail
+      else List.append [VarParam(name, minor)] (handle_args args tail)     
+  | [] -> []
+    | _-> raise X_syntax_error;;
+
+let rec params_to_vars params i =
+  match params with
+  | param :: tail -> [VarParam(param, i)] @ (params_to_vars tail (i+1))
+  | [] -> []
+
+  (* funcion that handel lambdas and boxed params *)
+let rec handle_lambda params body =
+  match body with
+  | Const'(x) -> Const'(x)
+
+  | Var'(var) -> 
+    (match var with
+    | VarFree(x) -> Var'(var)
+    | _ -> BoxGet'(var)
+    )
+
+  | BoxSet'(var, expr) ->  BoxSet'(var, handle_lambda params expr)
+  
+  | If'(test, dit, dif) ->
+    If'(handle_lambda params test, handle_lambda params dit, handle_lambda params dif)
+
+  | Or'(exprs) ->
+    Or'(List.map (fun(expr) -> handle_lambda params expr) exprs)
+  
+  | Seq'(exprs) -> 
+    Seq'(List.map (fun(expr) -> handle_lambda params expr) exprs)
+
+  | Set'(var, expr) -> 
+    (match var with
+    | VarFree(x) -> Set'(VarFree(x) , (handle_lambda params expr))
+    | _ -> BoxSet'(var, handle_lambda params expr)
+    )
+
+  | Def'(var, expr) -> Def'(var, handle_lambda params expr)
+
+  | LambdaSimple'(args, _body) ->
+    let new_args = handle_args args params in 
+    LambdaSimple'(args, handle_lambda new_args _body)
+
+  | LambdaOpt'(args, args_opt, _body) ->
+    let total_args = params_to_vars (args@[args_opt]) 0 in
+    let new_args = params @ total_args in 
+    LambdaOpt'(args, args_opt, handle_lambda new_args _body)
+
+  | Applic'(rator, rands) ->
+    Applic'(handle_lambda params rator, List.map (fun(rand) -> handle_lambda params rand) rands)
+  
+  | ApplicTP'(rator, rands) ->
+    ApplicTP'(handle_lambda params rator, List.map (fun(rand) -> handle_lambda params rand) rands)
+
+  | e -> e ;;
+
+  (* create set! Box exprs for all params *)
+let update_body_with_set params body =
+  match params with
+  | [] -> handle_lambda params body
+  | _ -> let set_params = List.map (fun(param) -> Set'(param, Box'(param))) params in
+            (match body with
+            | Seq'(lst) -> let _body = handle_lambda params body in
+                            (match _body with
+                            | Seq'(lst) -> Seq'(List.append set_params lst)
+                            | _ -> _body)     
+                            
+            | _ -> 
+                let _body = handle_lambda params body in            
+                Seq'(List.append set_params [_body]));;
+  
+
+  (* main box function *)
+let rec box_set_rec e =
+  match e with
+  | If'(test, dit, dif) ->
+    If'(box_set_rec test, box_set_rec dit, box_set_rec dif)
+
+  | Seq'(lst) -> 
+    Seq'(List.map (fun(s) -> box_set_rec s) lst)
+
+  | Set'(var, expr) -> 
+    Set'(var,  box_set_rec expr)
+
+  | Def'(var, expr) -> 
+    Def'(var, box_set_rec expr)
+
+  | Or'(lst) -> 
+    Or'(List.map (fun(expr) -> box_set_rec expr) lst)
+
+  | LambdaSimple'(params, body) ->   
+    let params_list = params_to_vars params 0 in
+    let body_with_set = update_body_with_set params_list body in
+    LambdaSimple'(params, box_set_rec body_with_set)
+
+  | LambdaOpt'(params, params_opt, body) ->
+    let new_params = params @ [params_opt] in
+    let params_list = params_to_vars new_params 0 in
+    let body_with_set = update_body_with_set params_list body in
+    LambdaOpt'(params, params_opt, box_set_rec body_with_set)
+
+  | Applic'(rator, rands) ->
+    let new_rands = List.map (fun(rand) -> box_set_rec rand) rands in
+    Applic'(box_set_rec rator, new_rands)
+
+  | ApplicTP'(rator, rands) ->
+    let new_rands = List.map (fun(rand) -> box_set_rec rand) rands in
+    ApplicTP'(box_set_rec rator, new_rands)
+
+  | BoxSet'(var,expr) -> BoxSet'(var, box_set_rec expr)
+
+  | e -> e;;
+  
+  ;;
+
+let box_set e = box_set_rec e;;
 
 let run_semantics expr =
   box_set
     (annotate_tail_calls
        (annotate_lexical_addresses expr));;
   
-end;; (* struct Semantics *)
 
 
+       end;; (* struct Semantics *)
+
+        (* open Semantics;;
+        List.map run_semantics 
+        [Def (Var "x", Const (Sexpr (Number (Fraction (5, 1)))));
+        Def (Var "x", Const (Sexpr (Number (Fraction (3, 1))))); Var "x"];; *)
\ No newline at end of file
diff --git a/stdlib.scm b/stdlib.scm
index 2e4a76e..7b826fc 100644
--- a/stdlib.scm
+++ b/stdlib.scm
@@ -19,20 +19,37 @@
       (map-many f args)))))
 
 
+
 (define fold-left 
-  #;(Add your implementation here
-     Note: The file won't compile like this, beacuase your tag-parser requires define to have a second expression.
-     This is on purpose, so you don't compile the library without completing this implementation by mistake.))
+    (lambda (f u s)
+       (if (null? s)
+            u
+            (f (fold-left f u (without-last-element s)) (last-element s)))))
 
 (define fold-right
-  #;(Add your implementation here
-     Note: The file won't compile like this, beacuase your tag-parser requires define to have a second expression.
-     This is on purpose, so you don't compile the library without completing this implementation by mistake.))
+  (lambda (f u s)
+    (if (null? s)
+        u
+        (f (car s)
+          (fold-right f u (cdr s))))))
+
+(define last-element
+    (lambda (s)
+        (if (null? (cdr s))
+            (car s)
+            (last-element (cdr s)))))
+
+(define without-last-element
+    (lambda (s)
+        (if (null? (cdr s))
+            '()
+            (cons (car s) (without-last-element (cdr s))))))
 
 (define cons*
-  #;(Add your implementation here
-     Note: The file won't compile like this, beacuase your tag-parser requires define to have a second expression.
-     This is on purpose, so you don't compile the library without completing this implementation by mistake.))
+    (lambda (a . b)
+        (if (null? b)
+        a
+        (fold-right cons (last-element b) (cons a (without-last-element b))))))
 
 (define append
   (let ((null? null?)
@@ -90,14 +107,10 @@
 		      (/ 1 x)
 		      (fold-left / x y)))))
     (let ((^comparator
-	   (lambda (op)
-	     (letrec ((comparator
-		       (lambda (x ys)
-			 (or (null? ys)
-			     (and (op x (car ys))
-				  (comparator (car ys) (cdr ys)))))))
-	       (lambda (x . y)
-		 (comparator x y))))))
+	  (lambda (op)
+	    (lambda (x . ys)
+	      (fold-left (lambda (a b) (and a b)) #t
+			 (map (lambda (y) (op x y)) ys))))))
       (set! = (^comparator (^numeric-op-dispatcher _=)))
       (set! < (^comparator (^numeric-op-dispatcher _<))))))
 
diff --git a/tag-parser.ml b/tag-parser.ml
index 138249e..60f60b1 100644
--- a/tag-parser.ml
+++ b/tag-parser.ml
@@ -1,5 +1,5 @@
 #use "reader.ml";;
-
+open Reader;;
 type constant =
   | Sexpr of sexpr
   | Void
@@ -46,7 +46,7 @@ exception X_syntax_error;;
 
 module type TAG_PARSER = sig
   val tag_parse_expressions : sexpr list -> expr list
-end;; (* signature TAG_PARSER *)
+end;; (* signature TAG_PARSER   raise X_syntax_error *)
 
 module Tag_Parser : TAG_PARSER = struct
 
@@ -56,10 +56,296 @@ let reserved_word_list =
    "quasiquote"; "quote"; "set!"; "pset!"; "unquote";
    "unquote-splicing"];;  
 
+   let disjAST nt1 nt2 =
+    fun s ->
+    try (nt1 s)
+    with X_syntax_error -> (nt2 s);;
+  
+  let nt_noneAST _ = raise X_syntax_error;;
+    
+  let disj_list_AST nts = List.fold_right disjAST nts nt_noneAST;;
+
 (* work on the tag parser starts here *)
+let rec tag_parser s = disj_list_AST[mit_dif_exp;lambda_exp;const;if_exp;or_exp;define_exp;set_exp;begin_exp;applic_exp;
+let_expen;let_kleen_expen;and_wrraper;quasiquote_expen_wrraper;cond_exp;pset_exp;let_rec_expen_wrraper] s 
 
-let tag_parse_expressions sexpr = raise X_not_yet_implemented;;
+and const s = match s with
+| Nil -> Const(Sexpr(Nil)) (* ask *)
+| Bool(e) -> Const(Sexpr(Bool(e)))
+| Char(e)-> Const(Sexpr(Char(e)))
+| Number(e)->Const(Sexpr(Number(e)))
+| String(e)->Const(Sexpr(String(e)))
+| Pair(Symbol("quote"),Pair(x,Nil))->Const(Sexpr(x))
+| Symbol(e) when  not(List.mem e reserved_word_list) ->  Var(e)  (** do i need to pase "a" *)
+|_-> raise  X_syntax_error
+
+and if_exp s = match s with
+| Pair(Symbol("if"), Pair(test, Pair(dit, Pair(dif, Nil))))-> If(tag_parser test, tag_parser dit, tag_parser dif)
+| Pair(Symbol("if"), Pair(test,Pair(dit, Nil)))-> If(tag_parser test, tag_parser dit ,Const(Void))
+|_-> raise  X_syntax_error
+
+and applic_exp s = match s with
+| Pair(sexp,sexplist) -> Applic (tag_parser sexp, List.map (fun a-> (tag_parser a)) (sexprs_to_list sexplist)) 
+| _ -> raise X_syntax_error
+
+and or_exp s = match s with
+| Pair(Symbol ("or"), Nil) ->  Const (Sexpr(Bool false))
+| Pair(Symbol ("or"), Pair(e,Nil)) ->tag_parser e 
+| Pair(Symbol ("or"), or_list) ->Or(List.map (fun a-> (tag_parser a)) (sexprs_to_list or_list) )
+|_ -> raise X_syntax_error
+
+and define_exp s = match s with 
+| Pair (Symbol ("define"),Pair (var,Pair(e,Nil))) -> Def (tag_parser var,tag_parser e) 
+|_ ->raise X_syntax_error
+
+and set_exp s = match s with
+| Pair (Symbol ("set!"), Pair(var,Pair(e,Nil))) ->  Set (tag_parser var,tag_parser e)
+|_ ->raise X_syntax_error
+
+and begin_exp s = match s with
+| Pair(Symbol ("begin"), Nil) ->  Const (Void)
+| Pair(Symbol ("begin"), Pair(e,Nil)) ->tag_parser e 
+| Pair(Symbol ("begin"), begin_list) ->Seq (List.map (fun a-> (tag_parser a)) (flot_begin_exp begin_list) )
+|_ -> raise X_syntax_error
+
+and flot_begin_exp s = match s with 
+| Pair(Pair(Symbol"begin",s1),s2)-> (flot_begin_exp s1) @ (flot_begin_exp s2)
+| Pair(s1,s2)-> s1 :: (flot_begin_exp s2)
+| Nil -> []
+| s1 -> [s1]
+
+and lambda_exp s = match s with
+| Pair(Symbol "lambda",Pair(ribs,body)) -> (match ribs with
+| Symbol(e) ->  LambdaOpt ([],e,seq_exp (sexprs_to_list body) )
+| _ -> if(not (is_improper ribs)) 
+       then LambdaSimple(param ribs,seq_exp (sexprs_to_list body))
+       else  LambdaOpt(get_param_improper_list ribs,get_last_element ribs, seq_exp ( sexprs_to_list body)))
+|_-> raise  X_syntax_error
+
+and param s= match s with 
+|Nil -> []
+|Pair(Symbol(e),rest_list)-> [e] @ (param rest_list)
+|_ -> raise X_syntax_error
+
+and get_last_element s = match s with
+| Pair(_,Symbol(e))-> e
+| Pair(_,e)-> get_last_element e
+| _->raise X_syntax_error
+(*  not   handl a a a   *)
+and get_param_improper_list s = match s with
+|Pair(Symbol(e),Symbol(_))-> [e]
+|Pair(Symbol(e),rest_list)-> [e] @ (get_param_improper_list rest_list)
+|_ -> raise X_syntax_error
+
+and seq_exp s = 
+ match (List.length s) with
+| 0 ->  Const(Void)
+| 1 ->  tag_parser (List.hd s)
+| _ ->  Seq (seq_helper (List.map (fun a-> (tag_parser a)) s))
+
+and seq_helper list_expr = match list_expr with
+| []->[]
+| Seq(something) :: tail -> something @ (seq_helper tail)
+| something:: tail  -> [something] @ (seq_helper tail)
+
+and sexprs_to_list s= match s with
+| Pair(s1,s2)-> s1 :: (sexprs_to_list s2)
+| Nil -> []
+| s1 -> [s1]
+
+and is_improper s = match s with
+| Nil-> false
+| Pair(s1,s2)-> is_improper(s2)
+| _ -> true 
+
+
+(*  Macro-expansions *)   
+and let_expen s = match s with 
+| Pair (Symbol "let", sexp_let) -> (match sexp_let with
+   |Pair(ribs,body) -> tag_parser (Pair (Pair (Symbol "lambda",Pair (left_side_ribs ribs,body)),right_side_ribs ribs))
+   |_-> raise  X_syntax_error)
+
+|_ -> raise X_syntax_error
+
+and right_side_ribs s = match s with 
+| Nil -> Nil
+| Pair(Pair(Symbol(a),Pair(sexp,Nil)),e) -> Pair(sexp,(right_side_ribs e))
+| _ -> raise X_syntax_error 
+and left_side_ribs s = match s with 
+| Nil -> Nil
+| Pair(Pair(a,Pair(b,Nil)),c) -> Pair(a,left_side_ribs c)
+| _ -> raise X_syntax_error
+
+and let_kleen_expen s= match s with 
+| Pair (Symbol "let*", sexp_let) -> (match sexp_let with 
+| Pair(ribs,body) -> 
+  (match ribs with
+    |  Nil-> tag_parser(Pair((Symbol "let"), sexp_let))   
+    |  Pair(_,Nil) -> tag_parser(Pair((Symbol "let"), sexp_let))
+    |  Pair(rib,rest_ribs)->  
+          let_kleen_build_expen  (sexp_var_of_ribs_to_exp ribs) (sexp_value_of_ribs_to_exp ribs) (seq_exp (sexprs_to_list body)) 
+    |  _ -> raise X_syntax_error)
+|_ -> raise X_syntax_error)
+|_ -> raise X_syntax_error
+
+and sexp_var_of_ribs_to_exp s = match s with
+|Nil-> []
+| Pair(Pair(Symbol(var), Pair(value, Nil)),rest_ribs) -> [var] @ (sexp_var_of_ribs_to_exp rest_ribs)
+| _ -> raise X_syntax_error
+
+and sexp_value_of_ribs_to_exp s = match s with
+|Nil->[]
+|Pair(Pair(Symbol(var), Pair(value, Nil)), rest_ribs) -> [tag_parser value] @ (sexp_value_of_ribs_to_exp rest_ribs)
+|_ -> raise X_syntax_error
+
+and let_kleen_build_expen vars values body = match vars, values with
+| [var], [value] -> Applic(LambdaSimple([var], body), [value])
+| var :: rest_var, value :: rest_value -> Applic(LambdaSimple([var], let_kleen_build_expen rest_var rest_value body ),[value])
+| _ -> raise X_syntax_error
+
+
+and and_wrraper s = match s with
+| Pair(Symbol "and", sexpr) -> tag_parser (and_expen_rec sexpr)
+| _ -> raise X_syntax_error
+
+and and_expen_rec = function
+| Nil -> Bool(true)
+| Pair(bool_val,Nil) -> bool_val
+| Pair(bool_val,bool_tail) ->  Pair(Symbol("if"), Pair(bool_val, Pair(and_expen_rec bool_tail ,Pair(Bool(false),Nil))))
+| _ -> raise X_syntax_error
+
+and mit_dif_exp s = match s with
+| Pair(Symbol("define"), Pair(Pair (Symbol var,arglist),body)) -> tag_parser (mit_def_rec var arglist body)
+| _ -> raise X_syntax_error
+
+and mit_def_rec var arglist body = 
+Pair(Symbol("define"), Pair(Symbol(var), Pair(Pair(Symbol("lambda"),Pair(arglist,body)), Nil))) 
+
+
+and args_helper arg_exp = match arg_exp with
+| Var(x) -> [x]
+| Seq(lst)-> list_arg lst 
+| _ -> raise X_syntax_error
+
+
+and list_arg list_args = match list_args with
+| []->[]
+| Var(x)::tail -> [x]@(list_arg tail)
+|_-> raise  X_syntax_error
+ 
+and cond_exp s = match s with
+| Pair (Symbol "cond" ,ribs) -> cond_ribs ribs
+| _ -> raise X_syntax_error
+
+and cond_ribs ribs =  match ribs with
+| Nil -> Const(Void)
+|Pair(first_rib,rest_ribs) -> 
+  (match first_rib with 
+    |Pair (Symbol("else"),sexpr) -> seq_exp (sexprs_to_list sexpr)
+    |Pair(test,Pair(Symbol("=>"),Pair(then_sexper, Nil))) -> 
+      let parm1 = Pair(Symbol("value"), Pair(test, Nil)) in
+      let parm2 = Pair(Symbol("f"),  Pair(Pair(Symbol("lambda"),Pair(Nil,Pair(then_sexper,Nil))),Nil)) in 
+      let parm3 = Pair(Symbol("rest"),  Pair(Pair(Symbol("lambda"), Pair(Nil, Pair(Pair(Symbol("cond"), rest_ribs), Nil))), Nil)) in
+      let body = Pair (Symbol "if", Pair (Symbol "value", Pair (Pair (Pair (Symbol "f", Nil), Pair (Symbol "value", Nil)), Pair (Pair (Symbol "rest", Nil), Nil)))) in
+      let params = Pair(parm1,Pair(parm2,Pair(parm3,Nil))) in 
+      tag_parser (Pair(Symbol("let"),Pair(params,Pair(body,Nil))))
+
+    |Pair(test,then_sexper) -> If(tag_parser test,seq_exp (sexprs_to_list then_sexper),cond_ribs rest_ribs)
+    | _ -> raise X_syntax_error)
+ |_-> raise  X_syntax_error
+
+and quasiquote_expen_wrraper s = match s with
+| Pair(Symbol "quasiquote", Pair(sexpr, Nil)) -> tag_parser (quasiquote_expen_rec sexpr)
+| _ -> raise X_syntax_error
+
+and quasiquote_expen_rec s = match s with
+| Nil ->  Pair(Symbol("quote"), Pair(Nil, Nil))
+| Symbol(blabla) -> Pair(Symbol("quote"), Pair(Symbol(blabla), Nil))
+| Pair(Symbol("unquote"), Pair(sexp, Nil)) -> sexp
+| Pair(Symbol("unquote-splicing"), sexp) -> raise X_syntax_error
+| Pair(a,b) -> quasiquote_helper s quasiquote_expen_rec
+| x -> x
+
+and quasiquote_helper touple expander = match touple with
+| Pair(Pair(Symbol("unquote-splicing"), Pair(sexpr, Nil)), b) -> Pair(Symbol("append"), Pair(sexpr, Pair(expander b, Nil))) 
+(* | Pair(a ,Pair(Symbol("unquote-splicing"), Pair(sexpr, Nil))) -> Pair(Symbol("cons"), Pair(expander a , Pair(sexpr, Nil))) *)
+| Pair(a, b) -> Pair(Symbol "cons",Pair(expander a, Pair(expander b,Nil)))
+(* Pair(Symbol "cons" , [quasiquote_expen_rec a, quasiquote_expen_rec b]) *)
+| _ -> raise X_syntax_error
+
+and pset_exp s =
+match s with 
+| Pair(Symbol("pset!"),binding) -> pset_binding_exp binding 
+| _-> raise X_syntax_error
+
+and pset_binding_exp s = 
+let left_string_arr_side = sexprs_to_list_srting (left_side_ribs s) in
+let right_side = sexprs_to_list (right_side_ribs s) in
+let upper_left = (List.map  (fun a-> String.uppercase_ascii a)  left_string_arr_side)  in
+let new_binding = make_new_binding upper_left right_side in
+let body = make_body left_string_arr_side upper_left in
+let let_exp = Pair(Symbol("let"),Pair(new_binding,body)) in  
+tag_parser  let_exp
+
+
+and make_body lower_left upper_right = match  lower_left,upper_right  with
+| [],[] -> Nil
+| first_left::tail_left , first_right::tail_right -> Pair(Pair(Symbol("set!"),Pair(Symbol(first_left),Pair(Symbol(first_right),Nil))),make_body tail_left tail_right )
+| _ -> raise X_syntax_error
+
+and make_new_binding left right = match  left,right  with
+| [],[] -> Nil
+| first_left::tail_left , first_right::tail_right -> Pair(Pair(Symbol(first_left),Pair(first_right,Nil)),make_new_binding tail_left tail_right )
+| _ -> raise X_syntax_error
+
+and sexprs_to_list_srting  s= match s with
+| Pair(Symbol(s1),s2)-> s1 :: (sexprs_to_list_srting s2)
+| Nil -> []
+|_ -> raise X_syntax_error
+
+and let_rec_split_ribs = function
+  | Nil -> Nil
+  | Pair(Pair(f,expr),tail) -> Pair(Pair(f ,Pair(Pair(Symbol "quote",Pair(Symbol "whatever", Nil)),Nil)), let_rec_split_ribs tail)
+  | _ -> raise X_syntax_error
+
+and let_rec_set ribs body = 
+  match ribs with
+  | Nil -> body
+  | Pair(Pair(f,Pair(expr,Nil)), tail) -> Pair(Pair(Symbol "set!", Pair(f, Pair(expr,Nil))),(let_rec_set tail body))
+  | _ -> raise X_syntax_error
+
+and let_rec_expen_wrraper s = match s with 
+  | Pair (Symbol "letrec", sexp_let) -> tag_parser (let_rec_expen sexp_let)
+  | _ -> raise X_syntax_error
+
+and let_rec_expen s = match s with
+  | Pair(Nil, body) -> (Pair(Symbol("let"), Pair(Nil, body)) )
+  | Pair(ribs, body) -> let params = let_rec_split_ribs ribs in
+                        let new_body = let_rec_set ribs (Pair(Pair(Symbol("let"), (Pair (Nil, body))),Nil)) in
+                        Pair(Symbol("let"), Pair(params, new_body))
+  | _ -> raise X_syntax_error;;
+
+
+
+
+let tag_parse_expressions sexpr = List.map (tag_parser) sexpr;;
 
-  
 end;; (* struct Tag_Parser *)
 
+
+(* open Tag_Parser;;
+let s = "
+(define rocket (char->integer '\\r))
+(define frily (char->integer '\\f))
+
+(not (> frily rocket))
+";;
+(Tag_Parser.tag_parse_expressions
+                  (Reader.read_sexprs s)) *)
+(* [Pair (Symbol "begin",
+Pair (Number (Fraction (1, 1)),
+ Pair (Number (Fraction (2, 1)),
+  Pair
+   (Pair (Symbol "begin",
+     Pair (Number (Fraction (4, 1)), Pair (Number (Fraction (5, 1)), Nil))),
+   Pair (Pair (Symbol "begin", Pair (Number (Fraction (3, 1)), Nil)), Nil)))))] *)
\ No newline at end of file